<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/sky.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<style>
			.reveal .footer {
			position: absolute;
			bottom: 1em;
			left: 1em;
			font-size: 0.7em;


			}


			/*Theme overrides*/
			.reveal h1, .reveal h2, .reveal h3, .reveal h4, .reveal h5, .reveal h6 {
			text-transform: none;
			/* font-family: "Century Gothic", CenturyGothic, AppleGothic, sans-serif; */
			}
		</style>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section data-markdown data-separator="^~~~~" data-separator-vertical="^~" data-notes="^Note:">
					<textarea data-template>
## Scala for Java Developers
### Lesson 3
~
We'll continue with the previous exercises

Note:
- Because not everyone has finished the exercised
- And, there were a few concepts in those exercises which we should cover in more detail.
- So you can go back and try to solv ethe exercises using more idiomatic Scala.
~
<small>but first...</small>  
Let's explore two more features of Scala
~
## Option

Note:
- 
~
Scala's answer to null

Note:
- I'm sure you're all familiar with null... So what do you think of it?
~
>  "I call it my billion-dollar mistake  . . .   I couldn't resist the temptation to put in a null reference, simply because it was so easy to implement."

<div style="text-align: right"><small>- Tony Hoare, creator of null</small></div>

Note:
- Tony Hoare, also known for inventing quicksort, added nulls to ALGOL W back in 1965, and isn't a fan.
~
nulls are bad  
<br>
NullPointerExceptions should not happen

Note:
- An NPE happens when they you try to access a field on something that is null. 
- When you see an NPE, really you're discovering something program: that in that piece of code, the object may or may not be present.
- But unfortunately, you're finding that out at runtime! I'd much rather know about it at compile time.
~
Let's walk through a motivating example an Oracle blog post about Optional.  
<br>
http://www.oracle.com/technetwork/articles/java/java8-optional-2175753.html
~
```java
String version = computer.getSoundcard().getUSB().getVersion();
```

Note:
- What could go wrong with that code?
- Well, not all computers have a soundcard (e.g. RPi).
- Not all soundcards have USB
~
```java
String version = "UNKNOWN";
if(computer != null){
  Soundcard soundcard = computer.getSoundcard();
  if(soundcard != null){
    USB usb = soundcard.getUSB();
    if(usb != null){
      version = usb.getVersion();
    }
  }
}
```
Note:
- So this is the safe/defensive version.
- The API/types and the compiler didn't direct me to this, I just have to figure it out.
- And we can get too defensive; how do I know `usb.getVersion()` won't be null?
- It can silently change. Maybe the library makes something nullable, and when I upgrade I have no visibility of that.
~
You can use Java 8's Optional instead

Note:
- So this is largely accepted to be a problem, and in Java 8, Optional was added.
- And it existed in Guava before that.
- Who's familiar with Optional?
~
```java
String name = computer.flatMap(Computer::getSoundcard)
                      .flatMap(Soundcard::getUSB)
                      .map(USB::getVersion)
                      .orElse("UNKNOWN");
```

Note:
- If computer was Optional, and the usb getter returned Optional, we could have this.
- flatMap is a higher order function. It takes a function which takes the object inside the Optional and returns another Optional.
~
Unfortunately, this was only added in Java 8.  

<br>
Existing APIs still use null

Note:
- E.g. System.getenv, or .get on a map or collection.
- So you can't take too much advantage of this in Java.
- Most existing libraries/API that won't be changed to avoid breaking backwards compatibility, especially the standard library.
~
```scala
sealed trait Option[+A] {
	def get(): A
	def map[B](f: A => B): Option[B]
	def getOrElse[B>:A](default: => B): B
	def orElse[B>:A](ob: => Option[B]): Option[B]
	def filter(f: A => Boolean): Option[A]
	def flatMap[B](f: A => Option[B]): Option[B]
}

case class Some[+A](get: A) extends Option[A]
case object None extends Option[Nothing]
```

Note:
- Scala has Option which is very similar to Java's Optional
- Here's the simplified signature of Option.
- get have .get, .map, .flatMap etc just like Java.
- An important point is that this has been in Scala from the beginning. So the standard library and other libraries all heavily use this. 
- You can rely on it being there in idiomatic Scala code/libraries. You don't have to be defensive.
~
```scala
val name = computer.flatMap(_.getSoundcard)
				   .flatMap(_.getUSB)
				   .map(_.getVersion)
				   .getOrElse("UNKNOWN")
```

Note:
- Java's Optional example translates to this in Scala.
- But in Scala it's idiomatic to keep it an Option as long as possible. So it would become...
~
```scala
val name = computer.flatMap(_.getSoundcard)
				   .flatMap(_.getUSB)
				   .map(_.getVersion)
```

Note:
- Whomever uses `name` has more imformation if we give them an empty Option (AKA None).
- If we return UNKNOWN they may end up checking for that
~
But we can rewrite that again:

```scala
val name = for {
  c   <- computer
  sc  <- c.getSoundcard
  usb <- sc.getUSB
} yield usb.getVersion
```

Note:
- This brings us into another feature in Scala.
- This is called a for-comprehension.
- You'll notice the `for` keyword. So this kind of looks like a for loop.
- But we're not working with a list, so what on earth is going on?!
~~~~
## For-comprehensions

Note:
- That last example used a for-comprehension.
- Something similar to a for loop, which can also work on options.
~
foreach

```scala
val otherTeachers = List("Sonia", "Povilas")

for (teacher <- otherTeachers) {
  println(s"Thanks $teacher for helping teach!")
}
```

Note:
- Here's a "for-loop" in Scala
- Looks similar to Java
- But actually, this is syntacic sugar for...
~
foreach

```scala
val otherTeachers = List("Sonia", "Povilas")

for (teacher <- otherTeachers) {
  println(s"Thanks $teacher for helping teach!")
}

otherTeachers.foreach( teacher => 
  println(s"Thanks $teacher for helping teach!")
)
```

Note:
- But really, this is a "for-comprehension"
- The compiler changes it into foreach; these are completely equivalent
~
map (in Java)  

```java
List<Integer> numbers = ...


List<Integer> squares = new ArrayList<>();
for (int n : numbers) {
  squares.add(n ^ 2)
}

List<Integer> squares2 = numbers.stream().map(square)
                          .collect(Collectors.toList());
```
~
map (in Scala)  

```scala
val numbers = 1 to 10

val squares = for (n <- numbers) yield n ^ 2

val squares2 = numbers.map(n => n ^ 2)
```

Note:
- Just like if-statements and everything else, for-comprehensions return a value.
- With foreach, the point is to have a side effect. So there's nothing to return and `Unit` is returned.
- But here, notice the `yield` keyword.
- We're going through a list, and returning a new value for each number in the list.
- The yield in the for-comprehension gets turned into a .map operation.
~
What else does it do?

- filter
- flatMap
- not just for collections

Note:
- We just looked at how to use for-comprehensions to in place of `.map` and `.filter` on collections.
- But it can actually do more, which I won't get into today, but we'll cover later in the course.
- We can do filtering inside a for-comprehension
- We can use flatMap, which we saw in the soundcard usb version example earlier. 
- flatMap, in the context of collections, lets us handle nested loops in a for-comprehension
- And interestingly, for-comprehensions work on more than just collections. 
~~~
Ways to implement `findMaxPrice`  


- Start with imperative with while loop
- Show with recursion
- Show with foldLeft
- Talk about the initial value needing to be Option.empty[Int]
  - Type inference works left to right. 
  - I didn’t learn this for like a year into Scala
- Using .get on map and then rewrapping. Ignoring the case when there’s an empty list
- Using functions on map (.map and .orElse)
- Using pattern matching 
  - Which we haven’t taught yet, but we’ll cover more later in the course. This is just a taster.
    - Mention that for-comprehensions can’t be used for folding.
Exercise - continue with the exercises. If you finish, try using for-comprehensions.
					</textarea>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				history: true,
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'socket.io/socket.io.js', async: true },
		      { src: 'plugin/notes-server/client.js', async: true }
				]
			});
		</script>
	</body>
</html>
